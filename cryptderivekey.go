package cryptderivekey

import (
	"crypto/md5"
	"crypto/sha1"
	"fmt"
	"strings"
)

func md5HashSlice(data []byte) []byte {
	md5Hash := md5.Sum(data)

	return md5Hash[:]
}

func sha1HashSlice(data []byte) []byte {
	sha1Hash := sha1.Sum(data)

	return sha1Hash[:]
}

func CryptDeriveKey(key []byte, hashType string) ([]byte, error) {
	// https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptderivekey
	// https://www.fireeye.com/content/dam/fireeye-www/global/en/blog/threat-research/flareon2016/challenge2-solution.pdf

	var key_hash, b0_hash, b1_hash []byte

	// Initialise byte arrays with required padding bytes
	b0 := [64]byte{0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36}

	b1 := [64]byte{0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C}

	if strings.ToLower(hashType) == "md5" {
		key_hash = md5HashSlice(key)
	} else if strings.ToLower(hashType) == "sha1" {
		key_hash = sha1HashSlice(key)
	} else {
		return []byte{0}, fmt.Errorf("%s is not a valid hash type to derive key for.", hashType)
	}

	for i, x := range key_hash {
		b0[i] = x ^ 0x36
		b1[i] = x ^ 0x5C
	}

	if strings.ToLower(hashType) == "md5" {
		b0_hash = md5HashSlice(b0[:])
		b1_hash = md5HashSlice(b1[:])
	} else if strings.ToLower(hashType) == "sha1" {
		b0_hash = sha1HashSlice(b0[:])
		b1_hash = sha1HashSlice(b1[:])
	}

	// Return the whole derived key, which the amount required can be determined by the caller
	// Need the '...' at the end to tell it to append the whole slice
	return append(b0_hash[:], b1_hash[:]...), nil
}
